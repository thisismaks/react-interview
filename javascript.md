## JavaScript
### Модули
разница между импортами ес6 и комон жс реквайр? реквайр беискли фанкенс 
динамические и статические импорты. - дополнить!
статический импорт на этапе сборки и поэтому позволяет анализировать - откидывать лишнее (тришейкин) и тд. 
динамический во время выполнения.
https://web-standards.ru/articles/critical-and-progressive-css
в модулях всегда use strict
код модуля выполняется один раз, сколько бы его раз не импортировали
В модуле на верхнем уровне this не определён (undefined).
Модули всегда выполняются в отложенном (deferred) режиме.

### Типы
- Undefined ```JS typeof instance === "undefined"```
- Boolean ```JS typeof instance === "boolean"```
- Number ```JS typeof instance === "number"```
- String ```JS typeof instance === "string"```
- BigInt ```JS typeof instance === "bigint"```
- Symbol ```JS typeof instance === "symbol"```
- Null ```JS typeof instance === "object"```
- Object ```JS typeof instance === "object"```

_почему null object - 1) нулевая ссылка; 2) можно создать объект с прототипом null_

### Объявления переменных
let, const - блочная область видимости, var - функциональная. 
var всплывает с undefined.

var можно переобъявить?
без всего a = 1 - глобальная видимости или на уровне модуля?

### Spread operator
в объект можно спредить undefined
```JS
const a = { ...undefined };
```
в массив undefined не спредится
```JS
const arr = undefined;
const b = [...(arr ?? [])];
```
_спреды в циклах часто приводят к ненужному созданию нового инстанса._

### операторы ??, ??=, ||=, &&=
(??) нулевое слияние — возвращает значение правого операнда, если значение левого операнда содержит null или undefined, в противном случае возвращается значение левого операнда.

(??=) нулевое присваивание — присваивает значение переменной x, если она содержит похожее на null значение (en-US) (null или undefined). options.duration ??= 100;

(||=) присваивание логического или — присваивает значение переменной x только в случае, если её текущее значение ложноподобно.
```JS
const a = { duration: 50, title: '' };

a.duration ||= 10;
// console.log(a.duration) - 50

a.title ||= 'title is empty';
// console.log(a.title) - "title is empty"
```

(&&=) присваивание логического И — присваивает значение переменной x только в случае, если её текущее значение истинноподобно.
```JS
let a = 1;
let b = 0;

a &&= 2;
// console.log(a) - 2

b &&= 2;
console.log(b);
// console.log(b) 0
```
### Что такое функция высшего порядка?
Функция которая принимает и/или возвращает другую функцию.

### Что такое абстрактный класс?
Нужны для того чтобы от них наследоваться. Нельзя получить инстанс, т.е. сконструировать с помощью оператора new.

### Что такое замыкание?
Это комбинация функции и лексического окружения, в котором эта функция определена.

### Чем отличается __proto__ от prototype?
prototype - есть только у функции и классов, ссылается на функцию конструктор прототипа.  
__proto__ позволяет перемещаться по цепочке прототипов. А prototype это свойство функции которое позволяет добавлять что-то в конструктор.  
__proto__  это ссылка на родительский объект.  
через  __proto__ идет обращение к методу родителя - цепочка прототипов - myArr.__proto__.__proto__.valueOf.apply(myArr);  
(есть у всех объектов кроме того у которого прототип null)
- prototype - свойство класса 
- __proto__ - свойство экземпляра класса

### Чем отличается итерации по объекту через for in и Object.keys()?
for in пойдет по всей цепочке прототипов, поэтому надо проверять через hasOwnProperty  
object.keys() только по ключам объекта.

### Чем отличается { ...obj1 } и Object.assign()?
Object.assign() мутирует существующий объект, спред оператор создает новый. Как следствие  Object.assign() позволяет использовать методы объекта назначения.

### Что такое Promise?
дописать

### Как принудительно отправить функцию в очередь микрозадач?
```JS
  queueMicrotask()
  // или
  Promise.resolve().then(() => {});
```

### Дескрипторы
writable – если true, свойство можно изменить, иначе оно только для чтения.
enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.
```JS
let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
Object.defineProperty(obj, propertyName, descriptor)
```

### Function
4 способа вызова функции:
- как функция - this от глобального объекта или undefind в strictMode
- как метод объекта - this от объекта
- через new - this от вновь созданного объекта (new fn() возвращает объект созданные через new или любой другой, но никогда простое значение)
- через call, apply  

###  Arrow function
Без arguments.  
this по месту определения - _стрелочная функция получает контекст функции в которой определена, но не объекта!_

### Function declaration/expression
- function declaration - ```JSfunction() {};``` - создаются движком при инициализации модуля. Могут быть вызваны раньше своих определений. Блочная область видимости.
- function expression. ```JS const fn = function() {};``` создаётся, когда выполнение доходит до него, и затем уже может использоваться.

### Функции-констукторы
```JS
function User(name) {
  this.name = name;
  this.isAdmin = false;
}
let user = new User("Jack");
```
Когда функция-конструктор вызывается с оператором new, она создаёт новый объект и инициализирует его свойства. Это и является основной целью конструкторов – реализовать код для многократного создания однотипных объектов.

### Use strict
Влияет на всплытие, добавляет "строгий" undefined.

В обычном режиме JavaScript опечатка в имени переменной приводит к созданию новой глобальной переменной. В строгом режиме это приведет к ошибке, что защищает от случайного создания глобальных переменных.

В строгом режиме this undefined а не window/global, кроме SetTimeout
  
- восьмеричные числовые константы запрещены
- нельзя использовать строку "arguments" “eval” в качестве имени переменной
- нельзя использовать выражение with

https://msiter.ru/tutorials/javascript/js_strict

### This
В определении функции this ссылается на "владельца" функции. Если метод передается отдельно от объекта - контекст теряется.

Контекст выполнения (execution context) — это концепция, описывающая окружение, в котором производится выполнение кода.
GlobalEC -> GlobalEC|FistFunctionEC -> GlobalEC|FistFunctionEC|SecondFunctionEC -> GlobalEC|FistFunctionEC -> GlobalEC

### bind, apply, call
присвоить можно только один раз.
bind возвращает функцию с новым контекстом.

### Event loop
Как будет вести себя браузер при переполнении очереди (закцилить в микро и макро таске) - дописать
Если мы хотим запустить функцию асинхронно (после текущего кода), но до отображения изменений и до новых событий, то можем запланировать это через queueMicrotask.

Внимательно когда резолв внутри макротаски - setTimeout - дописать

### Web Workers
Не имеют доступа к DOM, поэтому основное их применение – вычисления. Они позволяют задействовать несколько ядер процессора одновременно.

### Promise
Промис убирает инверсию контроля. Мы не передаем во внешний код колбеки, которые будет или нет вызваны, а внешний код возвращает нам промис на который мы у себя сами вешаем колбеки. т.е. управление остается у нашего кода. Аналогия - в очереди тебе дают фишку у которой три лампочки - pending, fulfilled, rejected. Когда тебе надо ты смотришь на состояние и сам решаешь что тебе делать.

состояния - pending, fulfilled, rejected
статические методы - all, race, allSettled (resolve, reject)

тут () => {} выполняется синхронно. устанавливает таймер, который через 5 сек запускает r, которая запускает console.log```
```JS
const p = new Promise((r) => setTimeout(r, 5000, "resolve"));
p.then(console.log); // resolve через 5 сек
```

тут мы НЕ резолвим промис, а устанавливаем значение, которое он получил при резолве. потому что async функция может вернуть только промис
```JS
async function getData() {
 return await Promise.resolve("Hello, World!");
}
console.log(getData()); // pending
```
Если сделать getData().then(console.log); получим интуитивно ожидаемый "Hello, World!".

тут же (без асинк/авэйт) мы получим Hello, World!
```JS
function getData() {
 return Promise.resolve("Hello, World!");
}
console.log(getData()); // "Hello, World!"
```

тут мы “говорим” - создай новый промис и сразу выполни переданную функцию, чтобы  в замыкании запомнить функцию resolve .. она может быть вызвана когда-нибудь, но тут она вызывается сразу.
```JS
const p = new Promise((resolve) => resolve("resolved"));
console.log(p.then(console.log)); // resolved
```

### Class
Функция super вызывает конструктор наследуемого класса в контексте текущего инстанса.

### try catch finlaly
try..catch работает только в синхронном коде. На момент запуска функции, назначенной через setTimeout, try..catch уже выполнится.

### Генераторы и итераторы
Только значения yield итерируются
https://habr.com/ru/companies/ruvds/articles/417481/
дописать

### Symbol
Ключ для объекта но не строка. Всегда уникальный. Позволяет избежать конфликта имена. Есть глобальные символы.

https://devdocs.io/javascript/global_objects/symbol
https://qna.habr.com/q/491123


### Map, Set, Weakmap, Weakset
Необходимость иметь ключами не только string, number и symbol.

https://devdocs.io/javascript/global_objects/weakmap

### JavaScript задачки
### Object
что выведется - подвох! 
```JS
let o1 = { name: "maks" };
let o2 = o1;
o1 = { name: "skam" };
console.log(o1); // { name: 'skam' }
console.log(o2); // { name: 'maks' }
```

еще один с подвохом (как они придумывают такое говно!?)
```JS
function fn() {
    console.log(1, this);
}

fn();

const obj = {
    method: fn,
}

obj.method();

new fn();

window.fn();
```

### Стрелочная функция в объекте
```JS
const name = 'Alisa';
const obj = {
 name: 'John',
 getArrowName: () => `Hello, ${this.name}`,
 getName: function() { return `Hello, ${this.name}`; };
};

obj.getArrowName(); //"Hello, Alisa"
obj.getName(); //"Hello, John"
```
getName() работает как надо. А при вызове getArrowName(), this будет ссылаться не на obj, а на окружающее лексическое окружение - из функции. 

Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при её запуске.

т.е. стрелочная функция получает контекст вышестоящей функции, но не объекта!
