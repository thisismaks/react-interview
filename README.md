# react-interview
Вопросы к собесам

## Общие вопросы
### Что такое SOAP?
дописать

### Что такое REST?
Набор правил работы с HTTP/Методология работы с HTTP запросами - способ взаимодействия клиента и сервера с помощью HTTP запросов.  
Нет состояния - при каждом запросе клиент и сервер обмениваются полной информацией.

### Что такое иденпотентность?
Свойство, означающее, что повторный запрос не меняет состояние сервера.  
GET, PUT, DELETE - иденпотенты.  
POST - нет.  
PATCH - зависит от реализации на сервере. Если есть инкрементная операция то тоже не иденпотентен.

Иденпотентные методы можно автоматически повторять на клиенте при сбое соединения. Не иденпотентные повторять только через ошибку и обновление страницы.

### Что такое HTTP?
Протокол прикладного уровня для передачи данных по сети. Изначально для передачи HTML документов, сейчас для произвольных данных типа JSON и т.п.

### Из чего состоит HTTP запрос?
- метод запроса
- путь на сервере
- версия протокола
- хедеры
- body (опционально)

### Отличие версий HTTP?
дописать

### Что такое HTTPS?
дописать

### Методы HTTP?
- GET - получение метаинформации и файла
- HEAD - получение только метаинформации
- POST - добавить в коллекцию (неиденпотентен)
- PUT - добавить, заменить (по id)
- PATCH - изменить (по id) (неиденпотентен)
- DELETE
- OPTIONS - получить список доступных методов

### Статусы HTTP?
- 100 - информация
- 200 - ок
- 300 - ресурс перемещен и в ответе новый путь (чтобы работали старые ссылки и так же одноразовый ридерект например при нажатии на кнопку сохранить перекидывает на отредактированный пост)
- 400 - ошибка у клиента (нет доступа, несуществующий путь)
- 500 - ошибка сервера

### Заголовок HOST?
В HTTP 1.1 заголовок Host (домен.ру) обязательный - позволяет на одном ip адресе резолвить кучу доменов.

### Connection?
Connection - в 1.1 протоколе соединение может не закрываться после первой передачи. Чтобы управлять этим используется Connection: close и Connection: keep-alive в комбинации с keep-alive: timeout=5

### Cookie?
- httpOnly - нельзя получить из браузера
- secure - только по https
- maxEdge
- expired
- domain
- HTTPonly - Для защиты от XSS атак

### TCP/UDP?
дописать

### Что такое Cross-Origin Resource Sharing (CORS)?
Политика одинакового источника - протокол порт и хост.  
Веб приложения могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки. Cервер отвечает с Access-Control-Allow-Origin: * что означает, что к ресурсу может получить доступ с любого домена кросс-сайтовым способом.  
дописать - 3 заголовка запросов и 6 ответов 


## Browser
### Что происходит перед обновлением интерфейса?
После выполнения всех задач (микро и макро) перед обновлением интерфейса вызывается глобальная функция requestAnimationFrame().

### Что такое websocket?
Это протокол двунаправленного соединения на основе TCP.
Сразу после отправки ответа WebSocket-соединение считается установленным, клиент и сервер могут начинать двунаправленный обмен сообщениями по этому же TCP-соединению
```JS
  let socket = new WebSocket('ws://yourserver/path');
```

### Что такое Server-Sent Events (SSE)?
Server-Sent Events - односторонняя передача данных с сервера клиенту.
```JS
  let eventSource = new EventSource('http://yourserver/path');
```

### Что такое webComponents?
Это набор различных технологий, позволяющих создавать повторно используемые компоненты.
дописать

### scheduler.yield()?
дописать

### Попадают ли в render tree элементы с display: none?
Нет.

### Как происходит рендеринг (переход по ссылке)?
- парсится HTML и преобразуется в DOM дерево
- загружаются и парсятся CSS стили, преобразуются в CSSOM дерево
- формируется render-tree
- на основе render-tree рассчитывается layout (стадия)
- отрисовка - painting (стадия)
- группировка по слоям - composition (стадия)

### Директивы defer/async?
defer - загружает паралельно, но исполняет перед событием DOMContentLoaded, т.е исполняет после загрузки HTML (отложенное исполнение).  
async - также загружает параллельно, но сразу как загрузил исполняет, т.е. скрипт может выполняться раньше загрузки HTML.

_те. асинк и дефер загружают асинхронно но дефер откладывает выполнение на после того как произойдет рендер страницы. а асинк запускает выполнение сразу после загрузки и такой скрипт может заблокировать рендер._

es6 modules are deferred by default in most browsers

### Storages?
- sessionStorage и localStorage. Ключи и значения всегда строки.
- index db - sql db.
- cookie - пересылает этот фрагмент данных веб-серверу в составе HTTP-запроса. используются веб-серверами для идентификации пользователей и хранения данных о них

### Что такле Same-origin policy (SLP)?
простые запросы (simple request) - get, post, head.
дописать

### События?
Погружение. всплытие. погружение редко исп. пришло из браузера майкрософт. несткейпе было всплытие. оставили оба поведения.

### Critical render path?
воде это про то как браузер рендерит страницу.

### Совокупное изменение макета (CLS) 
дописать



## HTML
### Теги?
- header
- nav
- aside
- section
- acticle

### Чем отличаются теги <Image/> и <Picture/>?
дописать

## CSS (SCSS)
### Селекторы?
- универсальный - *{описание}
- селектор тегов - тег{...}
- селектор атрибутов - [атрибут тега]{...}
- класса - .класс {...}
- идентификаторы - #id{...}
- песвдокласс - селектор:псевдокласс {...}
- псеводэлемент - селектор:псеводоэлемент {...}

### Специфичность селектора
| Селектор                    | Синтаксис      | Специфичность | 
| --------------------------- | ---------------| --------------| 
| Встроенный стиль            | style={}       | 1000          |
| Селектор id                 | #id            | 100           |
| Селектор класса             | .classname     | 10            |
| Селектор атрибутов          | d[ref='abc']   | 10            |
| Селектор псевдокласса       | li:first-child | 10            |
| Селектор тегов              | div            | 1             |
| Селектор псеводоэлементов   | li:after       | 1             |

### Способы центрирования
| Метод                | Пример | 
| -------------------- | ------ | 
| Margin auto          | margin: 0 auto;  |
| Flexbox              | display: flex; justify-content: center; align-items: center; |
| Grid                 | display: grid; place-items: center; |
| Absolute positioning | position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; |
| Transform translate  | position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); |

### Типы позицирования CSS?
- static
- relative
- absolute
- fixed

### Какую проблему решает CSS Modules?
Изоляция. Конфликт имен.

### Что такое миксины (SCSS)?
Аналог функций.

### Oтличие директивы import от директивы use (SCSS)?
import - подтягивает весь файл (по сути склеиваются два файла).  
use - подтягивает только то что перечислил.

### Transform
Если для анимации использовать top, left и т.п. то происходит рефоу, репейн, копозишн, а если использовать transform только композишн, при этом композин на стороне видеокарты.



## JavaScript
### Модули
разница между импортами ес6 и комон жс реквайр? реквайр беискли фанкенс 
динамические и статические импорты. - дополнить!
статический импорт на этапе сборки и поэтому позволяет анализировать - откидывать лишнее (тришейкин) и тд. 
динамический во время выполнения.
https://web-standards.ru/articles/critical-and-progressive-css
в модулях всегда use strict
код модуля выполняется один раз, сколько бы его раз не импортировали
В модуле на верхнем уровне this не определён (undefined).
Модули всегда выполняются в отложенном (deferred) режиме.

### Типы
- Undefined ```JS typeof instance === "undefined"```
- Boolean ```JS typeof instance === "boolean"```
- Number ```JS typeof instance === "number"```
- String ```JS typeof instance === "string"```
- BigInt ```JS typeof instance === "bigint"```
- Symbol ```JS typeof instance === "symbol"```
- Null ```JS typeof instance === "object"```
- Object ```JS typeof instance === "object"```

_почему null object - 1) нулевая ссылка; 2) можно создать объект с прототипом null_

### Объявления переменных
let, const - блочная область видимости, var - функциональная. 
var всплывает с undefined.

var можно переобъявить?
без всего a = 1 - глобальная видимости или на уровне модуля?

### Spread operator
в объект можно спредить undefined
```JS
const a = { ...undefined };
```
в массив undefined не спредится
```JS
const arr = undefined;
const b = [...(arr ?? [])];
```
_спреды в циклах часто приводят к ненужному созданию нового инстанса._

### операторы ??, ??=, ||=, &&=
(??) нулевое слияние — возвращает значение правого операнда, если значение левого операнда содержит null или undefined, в противном случае возвращается значение левого операнда.

(??=) нулевое присваивание — присваивает значение переменной x, если она содержит похожее на null значение (en-US) (null или undefined). options.duration ??= 100;

(||=) присваивание логического или — присваивает значение переменной x только в случае, если её текущее значение ложноподобно.
```JS
const a = { duration: 50, title: '' };

a.duration ||= 10;
// console.log(a.duration) - 50

a.title ||= 'title is empty';
// console.log(a.title) - "title is empty"
```

(&&=) присваивание логического И — присваивает значение переменной x только в случае, если её текущее значение истинноподобно.
```JS
let a = 1;
let b = 0;

a &&= 2;
// console.log(a) - 2

b &&= 2;
console.log(b);
// console.log(b) 0
```
### Что такое функция высшего порядка?
Функция которая принимает и/или возвращает другую функцию.

### Что такое абстрактный класс?
Нужны для того чтобы от них наследоваться. Нельзя получить инстанс, т.е. сконструировать с помощью оператора new.

### Что такое замыкание?
Это комбинация функции и лексического окружения, в котором эта функция определена.

### Чем отличается __proto__ от prototype?
prototype - есть только у функции и классов, ссылается на функцию конструктор прототипа.  
__proto__ позволяет перемещаться по цепочке прототипов. А prototype это свойство функции которое позволяет добавлять что-то в конструктор.  
__proto__  это ссылка на родительский объект.  
через  __proto__ идет обращение к методу родителя - цепочка прототипов - myArr.__proto__.__proto__.valueOf.apply(myArr);  
(есть у всех объектов кроме того у которого прототип null)
- prototype - свойство класса 
- __proto__ - свойство экземпляра класса

### Чем отличается итерации по объекту через for in и Object.keys()?
for in пойдет по всей цепочке прототипов, поэтому надо проверять через hasOwnProperty  
object.keys() только по ключам объекта.

### Чем отличается { ...obj1 } и Object.assign()?
Object.assign() мутирует существующий объект, спред оператор создает новый. Как следствие  Object.assign() позволяет использовать методы объекта назначения.

### Что такое Promise?
дописать

### Как принудительно отправить функцию в очередь микрозадач?
```JS
  queueMicrotask()
  // или
  Promise.resolve().then(() => {});
```

### Дескрипторы
writable – если true, свойство можно изменить, иначе оно только для чтения.
enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.
```JS
let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
Object.defineProperty(obj, propertyName, descriptor)
```

### Function
4 способа вызова функции:
- как функция - this от глобального объекта или undefind в strictMode
- как метод объекта - this от объекта
- через new - this от вновь созданного объекта (new fn() возвращает объект созданные через new или любой другой, но никогда простое значение)
- через call, apply  

###  Arrow function
Без arguments.  
this по месту определения - _стрелочная функция получает контекст функции в которой определена, но не объекта!_

### Function declaration/expression
- function declaration - ```JSfunction() {};``` - создаются движком при инициализации модуля. Могут быть вызваны раньше своих определений. Блочная область видимости.
- function expression. ```JS const fn = function() {};``` создаётся, когда выполнение доходит до него, и затем уже может использоваться.

### Функции-констукторы
```JS
function User(name) {
  this.name = name;
  this.isAdmin = false;
}
let user = new User("Jack");
```
Когда функция-конструктор вызывается с оператором new, она создаёт новый объект и инициализирует его свойства. Это и является основной целью конструкторов – реализовать код для многократного создания однотипных объектов.

### Use strict
Влияет на всплытие, добавляет "строгий" undefined.

В обычном режиме JavaScript опечатка в имени переменной приводит к созданию новой глобальной переменной. В строгом режиме это приведет к ошибке, что защищает от случайного создания глобальных переменных.

В строгом режиме this undefined а не window/global, кроме SetTimeout
  
- восьмеричные числовые константы запрещены
- нельзя использовать строку "arguments" “eval” в качестве имени переменной
- нельзя использовать выражение with

https://msiter.ru/tutorials/javascript/js_strict

### This
В определении функции this ссылается на "владельца" функции. Если метод передается отдельно от объекта - контекст теряется.

Контекст выполнения (execution context) — это концепция, описывающая окружение, в котором производится выполнение кода.
GlobalEC -> GlobalEC|FistFunctionEC -> GlobalEC|FistFunctionEC|SecondFunctionEC -> GlobalEC|FistFunctionEC -> GlobalEC

### bind, apply, call
присвоить можно только один раз.
bind возвращает функцию с новым контекстом.

### Event loop
Как будет вести себя браузер при переполнении очереди (закцилить в микро и макро таске) - дописать
Если мы хотим запустить функцию асинхронно (после текущего кода), но до отображения изменений и до новых событий, то можем запланировать это через queueMicrotask.

Внимательно когда резолв внутри макротаски - setTimeout - дописать

### Web Workers
Не имеют доступа к DOM, поэтому основное их применение – вычисления. Они позволяют задействовать несколько ядер процессора одновременно.

### Promise
Промис убирает инверсию контроля. Мы не передаем во внешний код колбеки, которые будет или нет вызваны, а внешний код возвращает нам промис на который мы у себя сами вешаем колбеки. т.е. управление остается у нашего кода. Аналогия - в очереди тебе дают фишку у которой три лампочки - pending, fulfilled, rejected. Когда тебе надо ты смотришь на состояние и сам решаешь что тебе делать.

состояния - pending, fulfilled, rejected
статические методы - all, race, allSettled (resolve, reject)

тут () => {} выполняется синхронно. устанавливает таймер, который через 5 сек запускает r, которая запускает console.log```
```JS
const p = new Promise((r) => setTimeout(r, 5000, "resolve"));
p.then(console.log); // resolve через 5 сек
```

тут мы НЕ резолвим промис, а устанавливаем значение, которое он получил при резолве. потому что async функция может вернуть только промис
```JS
async function getData() {
 return await Promise.resolve("Hello, World!");
}
console.log(getData()); // pending
```
Если сделать getData().then(console.log); получим интуитивно ожидаемый "Hello, World!".

тут же (без асинк/авэйт) мы получим Hello, World!
```JS
function getData() {
 return Promise.resolve("Hello, World!");
}
console.log(getData()); // "Hello, World!"
```

тут мы “говорим” - создай новый промис и сразу выполни переданную функцию, чтобы  в замыкании запомнить функцию resolve .. она может быть вызвана когда-нибудь, но тут она вызывается сразу.
```JS
const p = new Promise((resolve) => resolve("resolved"));
console.log(p.then(console.log)); // resolved
```

### Class
Функция super вызывает конструктор наследуемого класса в контексте текущего инстанса.

### try catch finlaly
try..catch работает только в синхронном коде. На момент запуска функции, назначенной через setTimeout, try..catch уже выполнится.

### Генераторы и итераторы
Только значения yield итерируются
https://habr.com/ru/companies/ruvds/articles/417481/
дописать

### Symbol
Ключ для объекта но не строка. Всегда уникальный. Позволяет избежать конфликта имена. Есть глобальные символы.

https://devdocs.io/javascript/global_objects/symbol
https://qna.habr.com/q/491123


### Map, Set, Weakmap, Weakset
Необходимость иметь ключами не только string, number и symbol.

https://devdocs.io/javascript/global_objects/weakmap


## TypeScript
### Structure vs Nominative
дописать ?

### Утилитарные типы?
- Partial<Type> ​
- Required<Type> ​
- Readonly<Type> ​
- Record<Keys, Type> ​
- Exclude<UnionType, ExcludedMembers> ​
- Extract<Type, Union> ​
- Pick<Type, Keys> ​
- Omit<Type, Keys>

### Отличие type от interface?
Интерфейсы мержаться и наследуются.

Что может тип что не может интерфейс?
Абстрактный класс?

дописать

### Отличие never от void?
void - функция, возвращающая undefined  
never - функция не доводящая до return.

### Что такое дженерик?
Позволяет создавать гибкие переиспользуемые типы и определять тип в момент использования. Результирующий тип в зависимости от входного типа. Аналогия с функциями.

### Пример MyPick?
```JS
type MyPick<T, Key extends keyof T> = { [k in Key]: T[k] }
```

### Пример "условие"
```JS
type If<C extends Boolean, T, F> = C extends true ? T : F;

type A = If<true, 1, 2>
type B = If<false, 1, 2>

type C = If<null, 1, 2>
```

### Пример "concat"
```JS
const tuple = [1] as const;

type Concat<T extends readonly unknown[], U extends readonly unknown[]> = [...T, ...U];
type Arr1 = Concat<[1],[2]>
type Arr2 = Concat<typeof tuple,[2]>
```


## React
### Основное
- Декларативнось
- Комнонентность
- Поток данных сверху вниз
- Виртуальный дом

### Почему ушли от классовых компонентов?
- непонятные движения с super() и this
- дублирование логики в методах жизненного цикла - didMount, didUpdate
- wrapper hell и тут же непривычная для мозга композиция
- кстомные хуки относительно удобный способ шарить логику
- также есть абурдное мнение, что функциональные компоненты ускоряют первую отрисовку.

### Что такое Reconciliation?
Эвристический сравнения деревьев. Сравнивает элементы. Если разные строит новое дерево.

дописать

### Зачкем нужен forwardRef?
forwardRef - дописать

https://react.dev/learn/manipulating-the-dom-with-refs 

### errorBoundary компонент
didCatch - нельзя на хуках - почему?

дописать

### Оптимизация
- на чанки - react lazy
- кэширование запросов
- S3 или Simple Storage Service - дописать
  
### Lazy, Suspense
как работает https://youtu.be/FDAGYMiIEb8?si=7nUb3gcAQ1blqUXJ&t=44

Инструктирует вебпак отделить код в отдельные бандлы. Отмечает бандлы динамическими импортами, это значит, что вебпак запрашивает эти бандлы только когда они используются. Пока онПендинг suspense показывает fallback. Лучший юзкейс - разбиение по роутерам. Использовать только для тех частей, которые не участвуют в critical render path.

дописать

### useEffect, useLayoutEffect
найти тот видос где объясняют кейс когда useEffect запускается до пайнтига, а не после (вроде там связанно с рефлоу)

дописать

### Context
плюс - избежать прос дриллинга. 
минус - ренендер всех компонентов при изменении стейта контекста (этого можно минимизировать путем разбиения контестов, но у этого новые проблемы)
лучше использовать для “легких” редко меняющихся состояний типа аунтификации, темы, языка.

### Способы принудительного рендера компонента?
- изменение стейта
- изменение key
- изменить контекст
- изменить пропсы
- ререндер родителя

### Способы оптимизации приложения?
- минимизация
- lazy loading
- debounce
- webworkers
- virtualized lists
- component composition
- treeshaiking
- memo
- useMemo
- useCallback

### The too Reacts
- ui=f(data, state)
- state collocation
- fetch on render
- render while fetch
по мотивам The too Reacts - (Дэн) - дописать

### Что такое Virtual DOM?
Модель реального дом дерева (упрощенная). По сути модель модели. Позволяет сократить обращения к реальному дом дереву, за счет накопления изменений и механизма reconciliation.

### Что такое Reconciliation?
Сравнение виртуального дом дерева с предыдущей версией. Вычисляется разница. Точечно обновляется реальное дом дерево. Эвристический алгоритм сравнения основывается на двух предположениях:
- элементы с разными типами произведут разные деревья;
- разные ключи - разные деревья.

### Что такое React Fiber?
дописать

### досту к ноде через ref и через querySelector - разница?
Первый работает с механизмами реакт, второй идет напрямую.

### Redux
на архитектуре flux и кратко описать экшены редьюсеры мидлваре

дописать

## Задачи
### object
что выведется - подвох! 
```JS
let o1 = { name: "maks" };
let o2 = o1;
o1 = { name: "skam" };
console.log(o1); // { name: 'skam' }
console.log(o2); // { name: 'maks' }
```

еще один с подвохом (как они придумывают такое говно!?)
```JS
function fn() {
    console.log(1, this);
}

fn();

const obj = {
    method: fn,
}

obj.method();

new fn();

window.fn();
```

### Стрелочная функция в объекте
```JS
const name = 'Alisa';
const obj = {
 name: 'John',
 getArrowName: () => `Hello, ${this.name}`,
 getName: function() { return `Hello, ${this.name}`; };
};

obj.getArrowName(); //"Hello, Alisa"
obj.getName(); //"Hello, John"
```
getName() работает как надо. А при вызове getArrowName(), this будет ссылаться не на obj, а на окружающее лексическое окружение - из функции. 

Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при её запуске.

т.е. стрелочная функция получает контекст вышестоящей функции, но не объекта!

